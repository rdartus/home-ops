apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-scripts
  namespace: default
data:
  initScript.sh: |

    #!/bin/sh
    # Three scenarios
    # * Vault is not running yet
    # ** Just wait...
    # * Vault is running but not initialized
    # ** Exit, it needs to be initialized and unsealed manually
    # * Vault is running and initialized but sealed
    # ** Take action and unseal the vault, then exit
    # * Vault is running, initialized and unsealed
    # ** all is good, exit

    COUNT=1
    LIMIT=30
    while [ 1 ]
    do
      echo "Checking if Vault is up and running (try $COUNT)..." &> /proc/1/fd/1
      VAULT_STATUS=$(vault status $1 2>&1)
      EXIT_STATUS=$?
      echo "Initialize Vault"
      export STATUS=$(vault status | grep 'Initialized' | awk '{print $2}')
      echo "status vault $STATUS"
      if [ $STATUS = "false" ]; then
        vault operator init -key-shares=3 -key-threshold=2 | tee /config/cred/vault.init

        # Store master keys in consul for operator to retrieve and remove
        COUNTER=1
        cat /config/cred/vault.init  | grep '^Unseal' | awk '{print $4}' | for key in $(cat -); do
          echo  $key | tee /config/cred/vault-init-$COUNTER
          COUNTER=$((COUNTER + 1))
        done

        export ROOT_TOKEN=$(cat /config/cred/vault.init | grep '^Initial' | awk '{print $4}')
        echo  $ROOT_TOKEN | tee /config/cred/vault-root-token

        # echo "Remove master keys from disk"
        # shred /config/cred/vault.init

        echo "Unsealing Vault"
        vault operator unseal $(cat /config/cred/vault-init-1)
        vault operator unseal $(cat /config/cred/vault-init-2)

        echo "Vault init complete."

        echo "Start configuration"
        vault login $ROOT_TOKEN
        vault secrets enable kv-v2
        vault kv put kv-v2/postgresql/config username="jeank" password="pdpdpd"
        vault kv put kv-v2/pgadmin/config username="jeank" password="testpdpdpd"
        vault auth enable kubernetes
        vault write auth/kubernetes/config kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
        vault secrets enable -path=transit transit
        vault write -force transit/keys/vso-client-cache
        vault policy write demo-auth-policy-operator - <<EOFFF
        path "transit/encrypt/vso-client-cache" {
          capabilities = ["create", "update"]
        }
        path "transit/decrypt/vso-client-cache" {
          capabilities = ["create", "update"]
        }
        EOFFF
        vault write auth/kubernetes/role/auth-role-operator \
        bound_service_account_names=demo-operator \
        bound_service_account_namespaces=default \
        token_ttl=0 \
        token_period=120 \
        token_policies=demo-auth-policy-db \
        audience=vault
        
        vault policy write plcpgsql - <<EOF
        path "kv-v2/postgresql/config" {
          capabilities = ["read"]
        }
        vault write auth/kubernetes/role/rlpgsql \
        bound_service_account_names=default \
        bound_service_account_namespaces=default \
        policies=plcpgsql \
        ttl=24h
        EOF
        # vault policy write plcpgadmin - <<EOFF
        # path "kv-v2/pgadmin/config" {
        #   capabilities = ["read"]
        # }
        # vault write auth/kubernetes/role/rlpgadmin \
        # bound_service_account_names=default \
        # bound_service_account_namespaces=default \
        # policies=plcpgadmin \
        # ttl=24h
        # EOFF
        exit 0
      elif [ $COUNT -ge $LIMIT ]; then
        # Dont know what happened... Exiting
        echo "$VAULT_STAUS" &> /proc/1/fd/1
        exit 1
      else
        # For debugging
        echo "$VAULT_STATUS" &> /proc/1/fd/1
        ps aux &> /proc/1/fd/1
      fi
      COUNT=$((COUNT+1))
      sleep 1
    done