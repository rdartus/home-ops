# yaml-language-server: $schema=https://raw.githubusercontent.com/bjw-s-labs/helm-charts/refs/heads/main/charts/library/common/values.schema.json
---
global:
  # -- Set an override for the prefix of the fullname
  nameOverride:
  # -- Set the entire name definition
  fullnameOverride:
  # -- Propagate global metadata to Pod labels.
  propagateGlobalMetadataToPods: false
  # -- Set additional global labels. Helm templates can be used.
  labels: {}
  # -- Set additional global annotations. Helm templates can be used.
  annotations: {}

# -- Set default options for all controllers / pods here
# Each of these options can be overridden on a Controller level
defaultPodOptions:
  # -- Defines affinity constraint rules.
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
  affinity: {}

  # -- Set annotations on the Pod. Pod-specific values will be merged with this.
  annotations: {}

  # -- Specifies whether a service account token should be automatically mounted.
  automountServiceAccountToken: true

  # -- Configuring the ndots option may resolve nslookup issues on some Kubernetes setups.
  dnsConfig: {}

  # -- Defaults to "ClusterFirst" if hostNetwork is false and "ClusterFirstWithHostNet" if hostNetwork is true.
  dnsPolicy: ""

  # -- Enable/disable the generation of environment variables for services.
  # [[ref]](https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/#accessing-the-service)
  enableServiceLinks: false

  # -- Allows specifying explicit hostname setting
  hostname: ""

  # -- Use hostAliases to add custom entries to /etc/hosts - mapping IP addresses to hostnames.
  # [[ref]](https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/)
  hostAliases: []

  # -- Use the host's ipc namespace
  hostIPC: false

  # -- When using hostNetwork make sure you set dnsPolicy to `ClusterFirstWithHostNet`
  hostNetwork: false

  # -- Use the host's pid namespace
  hostPID: false

  # -- Use the host's user namespace (requires 1.29 or newer)
  hostUsers:

  # -- Set image pull secrets
  imagePullSecrets: []

  # -- Set labels on the Pod. Pod-specific values will be merged with this.
  labels: {}

  # -- Node selection constraint
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
  nodeSelector: {}

  # -- Custom priority class for different treatment by the scheduler
  priorityClassName: ""

  # -- Set Container restart policy.
  # @default -- `Always`. When `controller.type` is `cronjob` it defaults to `Never`.
  restartPolicy: ""

  # -- Allow specifying a runtimeClassName other than the default one (ie: nvidia)
  runtimeClassName: ""

  # -- Allows specifying a custom scheduler name
  schedulerName: ""

  # -- Configure the Security Context for the Pod
  securityContext: {}

  # -- Allows sharing process namespace between containers in a Pod
  # -- [[ref](https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/)]
  shareProcessNamespace:

  # -- Duration in seconds the pod needs to terminate gracefully
  # -- [[ref](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle)]
  terminationGracePeriodSeconds:

  # -- Specify taint tolerations
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
  tolerations: []

  # -- Defines topologySpreadConstraint rules.
  # [[ref]](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/)
  topologySpreadConstraints: []

controllers:
  main:
    # -- enable the controller.
    enabled: true
    type: job
    containers:
      main:
        dependsOn: ["gitsync"]
        image:
          # -- image repository
          repository: postgres
          # -- image tag
          tag: 16@sha256:23af655ba1ddf74eaa002e3deaf5fce022ab8791672336a7c1fb0ef2d57efb7f
          # -- image pull policy
          pullPolicy: IfNotPresent
        # -- Override the command(s) for the container
        command: 
        - /bin/sh
        - -c
        - |
          echo "verify files"
          ls -la /data/dump-k3s/
          echo "set .PGPASS"
          cd /
          echo cnpg-cluster-rw.database.svc.cluster.local:5432:*:$SUPERUSER:$PASSWORD > .pgpass
          chmod 0600 .pgpass
          cat .pgpass
          echo "wait"
          sleep 2m # depends on not really working for cluster & database resources
          ls -la /data/dump-k3s/

          # echo "restore dump_all"
          # psql "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" -v ON_ERROR_STOP=1 -f /data/dump-k3s/dumpall_clean.sql

          echo "restore dump_immich"
          pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_immich

          # echo "restore dump_prowlarr"
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_prowlarr
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_prowlarr
          # echo "restore dump_sonarr"
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_sonarr
          # echo "restore dump_radarr"
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_radarr
          # echo "restore dump_authentik"
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_authentik
          # echo "restore dump_mealie"
          # pg_restore --clean --create --if-exists -d "postgres://$SUPERUSER:$PASSWORD@cnpg-cluster-rw.database.svc.cluster.local/postgres" /data/dump-k3s/dump_mealie

        env:
          SUPERUSER:
            valueFrom:
              secretKeyRef:
                name: superuser-secret
                key: username
          PASSWORD:
            valueFrom:
              secretKeyRef:
                name: superuser-secret
                key: password

      gitsync:
        dependsOn: []
        image:
          repository: ghcr.io/rdartus/git-sync@sha256
          tag: 1e73176654edc824de658a270582edd815ac7cb4bae06de96d8aadaebc900ac9
          # -- image pull policy
          pullPolicy: IfNotPresent
        args: 
          - --repo=git@gitlab.com:k3s-pi1/dump-k3s.git
          - --depth=1
          - --period=1500s
          - --link=dump-k3s
          - --ref=main
          - --root=/data
          - --ssh-known-hosts=false
          - --ssh-key-file=/config/key
          - --git-LFS=true
          - --verbose=9
          - --exechook-timeout=300s
          - --sync-timeout=300s
          - --one-time
        # env:
        # securityContext:
        #   runAsUser: 65533

      # tools:
      #   dependsOn: []
      #   image:
      #     repository: alpine/git
      #     tag: latest
      #     # -- image pull policy
      #     pullPolicy: IfNotPresent
      #   command:
      #     - "sh"
      #     - "-c"
      #     - "while true; do sleep 6000; done"
        # env:
        # securityContext:
        #   runAsUser: 65533

# @default -- See below
secrets:
  {}
  # secret:
  #   # -- Enables or disables the Secret
  #   enabled: false
  #   # -- Labels to add to the Secret
  #   labels: {}
  #   # -- Annotations to add to the Secret
  #   annotations: {}
  #   # -- Secret stringData content. Helm template enabled.
  #   stringData:
  #     {}
  #     # foo: bar

# -- Configure configMaps for the chart here.
# Additional configMaps can be added by adding a dictionary key similar to the 'config' object.
# @default -- See below
configMaps:
  {}
  # config:
  #   # -- Enables or disables the configMap
  #   enabled: true
  #   # -- Labels to add to the configMap
  #   labels: {}
  #   # -- Annotations to add to the configMap
  #   annotations: {}
  #   # -- configMap data content. Helm template enabled.
  #   data:
  #     foo: bar

# -- Generate ConfigMaps from a folder in the Helm chart's filesystem
# Your files will need to be two levels deep from the base path.
# For example, if you set this to `files/`, you should have this file tree
# files:
# └── configmap1
#     ├── file1
#     └── file2
# This will generate a ConfigMap named `configmap1` with keys `file1` and `file2`.
configMapsFromFolder:
  enabled: false
  # #-- The path in your parent's chart filesystem where you can add files to be converted into individual ConfigMaps.
  # basePath: "files/configMaps"
  # #-- Define overrides for the generated ConfigMaps, each key is the name of a folder in `basePath`
  # configMapsOverrides:
  #   test:
  #     # All ConfigMaps support a `forceRename` field, which allows you to rename the ConfigMap
  #     forceRename: null
  #     annotations:
  #       test: test
  #     labels:
  #       test: test
  #     # Configure how the individual files are added to the ConfigMap
  #     fileAttributeOverrides:
  #       # The key is the name of the file inside the ConfigMap's folder
  #       test.tpl:
  #         # If true the file won't be added to the ConfigMap
  #         exclude: false
  #         # If your file is a binary file like an image, set this to true. Takes precedence over `escaped`
  #         binary: false
  #         # If your file contains `gotpl` syntax that you don't want templated by Helm, set this to true
  #         escaped: true
  #       test.txt:
  #         exclude: true
  #   test2:
  #     fileAttributeOverrides:
  #       image.png:
  #         binary: true

# -- Configure the services for the chart here.
# Additional services can be added by adding a dictionary key similar to the 'main' service.
# @default -- See below
service:
  {}
  # main:
  #   # -- Enables or disables the service
  #   enabled: true

  #   # -- Configure which controller this service should target
  #   controller: main

  #   # -- Make this the primary service for this controller (used in probes, notes, etc...).
  #   # If there is more than 1 service targeting the controller, make sure that only 1 service is
  #   # marked as primary.
  #   primary: true

  #   # -- Set the service type
  #   type: ClusterIP

  #   # -- Specify the internalTrafficPolicy for the service. Options: Cluster, Local
  #   # -- [[ref](https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/)]
  #   internalTrafficPolicy:

  #   # -- Specify the externalTrafficPolicy for the service. Options: Cluster, Local
  #   # -- [[ref](https://kubernetes.io/docs/tutorials/services/source-ip/)]
  #   externalTrafficPolicy:

  #   # -- Specify the ip policy. Options: SingleStack, PreferDualStack, RequireDualStack
  #   ipFamilyPolicy:
  #   # -- The ip families that should be used. Options: IPv4, IPv6
  #   ipFamilies: []

  #   # -- Provide additional annotations which may be required.
  #   annotations: {}

  #   # -- Provide additional labels which may be required.
  #   labels: {}

  #   # -- Allow adding additional match labels
  #   extraSelectorLabels: {}

  #   # -- Configure the Service port information here.
  #   # Additional ports can be added by adding a dictionary key similar to the 'http' service.
  #   # @default -- See below
  #   ports:
  #     http:
  #       # -- Enables or disables the port
  #       enabled: true

  #       # -- Make this the primary port (used in probes, notes, etc...)
  #       # If there is more than 1 service, make sure that only 1 port is marked as primary.
  #       primary: true

  #       # -- The port number
  #       port:

  #       # -- Port protocol.
  #       # Support values are `HTTP`, `HTTPS`, `TCP` and `UDP`.
  #       # HTTP and HTTPS spawn a TCP service and get used for internal URL and name generation
  #       protocol: HTTP

  #       # -- Specify a service targetPort if you wish to differ the service port from the application port.
  #       # If `targetPort` is specified, this port number is used in the container definition instead of
  #       # the `port` value. Therefore named ports are not supported for this field.
  #       targetPort:

  #       # -- Specify the nodePort value for the LoadBalancer and NodePort service types.
  #       # [[ref]](https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport)
  #       nodePort:

  #       # -- Specify the appProtocol value for the Service.
  #       # [[ref]](https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol)
  #       appProtocol:

# -- Configure the ingresses for the chart here.
ingress:
  {}

  # -- An example is shown below
  # main:
  #   # -- Enables or disables the ingress
  #   enabled: true

  #   # -- Override the name suffix that is used for this ingress.
  #   nameOverride:

  #   # -- Provide additional annotations which may be required. Helm templates can be used.
  #   annotations: {}

  #   # -- Provide additional labels which may be required. Helm templates can be used.
  #   labels: {}

  #   # -- Set the ingressClass that is used for this ingress.
  #   className:

  #   # -- Configure the defaultBackend for this ingress. This will disable any other rules for the ingress.
  #   defaultBackend:

  #   ## Configure the hosts for the ingress
  #   hosts:
  #     - # -- Host address. Helm template can be passed.
  #       host: chart-example.local
  #       ## Configure the paths for the host
  #       paths:
  #         - # -- Path.  Helm template can be passed.
  #           path: /
  #           pathType: Prefix
  #           service:
  #             # -- Overrides the service name reference for this path
  #             # The service name to reference.
  #             name: main
  #             # -- Reference a service identifier from this values.yaml
  #             identifier: main
  #             # -- Overrides the service port number reference for this path
  #             port:

  #   # -- Configure TLS for the ingress. Both secretName and hosts can process a Helm template.
  #   tls: []
  #   #  - secretName: chart-example-tls
  #   #    hosts:
  #   #      - chart-example.local

# -- Configure the ServiceMonitors for the chart here.
# Additional ServiceMonitors can be added by adding a dictionary key similar to the 'main' ServiceMonitors.
# @default -- See below
serviceMonitor:
  {}
  # main:
  #   # -- Enables or disables the serviceMonitor.
  #   enabled: false

  #   # -- Override the name suffix that is used for this serviceMonitor.
  #   nameOverride: ""

  #   # -- Provide additional annotations which may be required.
  #   annotations: {}

  #   # -- Provide additional labels which may be required.
  #   labels: {}

  #   # -- Configures a custom selector for the serviceMonitor, this takes precedence over
  #   # specifying a service name.
  #   # Helm templates can be used.
  #   selector: {}

  #   # -- Configures the target Service for the serviceMonitor. Helm templates can be used.
  #   serviceName: '{{ include "bjw-s.common.lib.chart.names.fullname" $ }}'

  #   # -- Configures the endpoints for the serviceMonitor. Helm templates can be used.
  #   # @default -- See values.yaml
  #   endpoints:
  #     - port: http
  #       scheme: http
  #       path: /metrics
  #       interval: 1m
  #       scrapeTimeout: 10s

  #   # -- Configures custom targetLabels for the serviceMonitor. (All collected
  #   # meterics will have these labels, taking the value from the target service)
  #   # [[ref]](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitorspec/)
  #   targetLabels: []

# -- Configure the gateway routes for the chart here.
# Additional routes can be added by adding a dictionary key similar to the 'main' route.
# [[ref]](https://gateway-api.sigs.k8s.io/references/spec/)
# @default -- See below
route:
  {}
  # main:
  #   # -- Enables or disables the route
  #   enabled: false

  #   # -- Set the route kind
  #   # Valid options are GRPCRoute, HTTPRoute, TCPRoute, TLSRoute, UDPRoute
  #   kind: HTTPRoute

  #   # -- Override the name suffix that is used for this route.
  #   nameOverride: ""

  #   # -- Provide additional annotations which may be required.
  #   annotations: {}

  #   # -- Provide additional labels which may be required.
  #   labels: {}

  #   # -- Configure the resource the route attaches to.
  #   parentRefs:
  #     - # Group of the referent resource.
  #       group: gateway.networking.k8s.io
  #       # Kind of the referent resource.
  #       kind: Gateway
  #       # Name of the referent resource
  #       name:
  #       # Namespace of the referent resource
  #       namespace:
  #       # Name of the section within the target resource.
  #       sectionName:

  #   # -- Host addresses. Helm template can be passed.
  #   hostnames: []

  #   # -- Configure rules for routing. Defaults to the primary service.
  #   rules:
  #     - # -- Optional name of the route rule. This name must be unique within a Route if it is set.
  #       name: ""
  #       # -- Configure backends where matching requests should be sent.
  #       backendRefs: []
  #       ## Configure conditions used for matching incoming requests. Only for HTTPRoutes
  #       matches:
  #         - path:
  #             type: PathPrefix
  #             value: /
  #       ## Request filters that are applied to the rules.
  #       filters: []
  #       ## Request timeout that are applied to the rules.
  #       timeouts: {}

# -- Configure persistence for the chart here.
# Additional items can be added by adding a dictionary key similar to the 'config' key.
# [[ref]](https://bjw-s-labs.github.io/helm-charts/docs/common-library/common-library-storage)
# @default -- See below
persistence:
  config:
  #   # -- Enables or disables the persistence item. Defaults to true
    enabled: true

  #   # -- Sets the persistence type
  #   # Valid options are persistentVolumeClaim, emptyDir, nfs, hostPath, secret, configMap or custom
    type: secret
    name: ssh-secret
    # defaultMode: 448
  data :
    enabled: true
    type: emptyDir

  
  #   # -- Storage Class for the config volume.
  #   # If set to `-`, dynamic provisioning is disabled.
  #   # If set to something else, the given storageClass is used.
  #   # If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner.
  #   storageClass: # "-"

  #   # -- If you want to reuse an existing claim, the name of the existing PVC can be passed here.
  #   existingClaim: # your-claim

  #   # -- The optional data source for the persistentVolumeClaim.
  #   # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-populators-and-data-sources)
  #   dataSource: {}

  #   # -- The optional volume populator for the persistentVolumeClaim.
  #   # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-populators-and-data-sources)
  #   dataSourceRef: {}

  #   # -- AccessMode for the persistent volume.
  #   # Make sure to select an access mode that is supported by your storage provider!
  #   # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes)
  #   accessMode: ReadWriteOnce

  #   # -- The amount of storage that is requested for the persistent volume.
  #   size: 1Gi

  #   # -- Set to true to retain the PVC upon `helm uninstall`
  #   retain: false

  #   # -- Configure mounts to all controllers and containers. By default the persistence item
  #   # will be mounted to `/<name_of_the_peristence_item>`.
  #   # Example:
  #   # globalMounts:
  #   #   - path: /config
  #   #     readOnly: false
  #   globalMounts: []

  #   # -- Explicitly configure mounts for specific controllers and containers.
  #   # Example:
  #   # advancedMounts:
  #   #   main: # the controller with the "main" identifier
  #   #     main: # the container with the "main" identifier
  #   #       - path: /data/config.yaml
  #   #         readOnly: true
  #   #         mountPropagation: None
  #   #         subPath: config.yaml
  #   #     second-container: # the container with the "second-container" identifier
  #   #       - path: /appdata/config
  #   #         readOnly: true
  #   #   second-controller: # the controller with the "second-controller" identifier
  #   #     main: # the container with the "main" identifier
  #   #       - path: /data/config.yaml
  #   #         readOnly: false
  #   #         subPath: config.yaml
  #   advancedMounts: {}

# -- Configure the networkPolicies for the chart here.
# Additional networkPolicies can be added by adding a dictionary key similar to the 'main' networkPolicy.
# @default -- See below
networkpolicies:
  {}
  # main:
  #   # -- Enables or disables the networkPolicy item. Defaults to true
  #   enabled: false

  #   # -- Configure which controller this networkPolicy should target
  #   controller: main

  #   # -- Define a custom podSelector for the networkPolicy. This takes precedence over targeting a controller.
  #   # podSelector: {}

  #   # -- The policyTypes for this networkPolicy
  #   policyTypes:
  #     - Ingress
  #     - Egress

  #   # -- The rulesets for this networkPolicy
  #   # [[ref]](https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource)
  #   rules:
  #     # -- The ingress rules for this networkPolicy. Allows all ingress traffic by default.
  #     ingress:
  #       - {}
  #     # -- The egress rules for this networkPolicy. Allows all egress traffic by default.
  #     egress:
  #       - {}

# -- Configure any unsupported raw resources here.
# @default -- See below
rawResources:
  {}
  # example:
  #   # -- Enables or disables the resource. Defaults to true
  #   enabled: false
  #   # -- Specify the apiVersion of the resource.
  #   apiVersion: v1
  #   # -- Specify the kind of the resource.
  #   kind: Endpoint
  #   # -- Override the name suffix that is used for this resource.
  #   nameOverride: ""
  #   # -- Provide additional annotations which may be required.
  #   annotations: {}
  #   # -- Provide additional labels which may be required.
  #   labels: {}
  #   # -- Configure the contents of the resource that is to be rendered.
  #   spec:

# -- Configure the Roles and Role Bindings for the chart here.
rbac:
  {}
  # roles:
  #   role1:
  #     # -- Force replace the name of the object.
  #     forceRename: <force name>
  #     # -- Enables or disables the Role. Can be templated.
  #     enabled: true
  #     # -- Set to Role,ClusterRole
  #     type: Role
  #     rules:
  #       - apiGroups: ["*"]
  #         resources: ["*"]
  #         verbs: ["get", "list", "watch"]
  # bindings:
  #   binding1:
  #     # -- Force replace the name of the object.
  #     forceRename: <force name>
  #     # -- Enables or disables the Role. Can be templated.
  #     enabled: true
  #     # -- Set to RoleBinding,ClusterRoleBinding
  #     type: RoleBinding
  #     # -- Can be an identifier of rbac.roles or a custom name and kind
  #     roleRef:
  #       name: test-role
  #       kind: Role
  #       identifier: test
  #     # -- If using an identifier it will be automatically filled, otherwise every key will need to be explicitly declared
  #     subjects:
  #       - identifier: default
  #       - kind: ServiceAccount
  #         name: test
  #         namespace: "{{ .Release.Namespace }}"
  #       - kind: Group
  #         name: oidc:/test-user
  #       - kind: User
  #         name: username